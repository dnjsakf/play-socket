<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style type="text/css">
    * { box-sizing: border-box; padding: 0; margin: 0; user-select: none; touch-action: none; }
  </style>
</head>
<body>
  <div>
    <select name="inputType">
      <option value="wasd">WASD</option>
      <option value="arrow">방향키</option>
    </select>
    , shape: 
    <select name="shape">
      <option value="rect">사각형</option>
      <option value="triangle">삼각형</option>
      <option value="circle">원형</option>
      <option value="image">이미지</option>
    </select>
    , color: 
    <select name="color">
      <option value="red">red</option>
      <option value="blue">blue</option>
      <option value="green">green</option>
    </select>
    <button id="addPlayer">+</button>
    <button id="stop">stop</button>
    <button id="reset">reset</button>
    <button id="destroy">destroy</button>
  </div>
  <div>
    <canvas id="canvas-playground"></canvas>
  </div>
  <script type="text/javascript">
    function StageUtil(){}
    StageUtil = (()=>{
      return {
        // 두 점 사이의 거리
        getDistance(x1, y1, x2, y2){
          // 거리의 제곱 = 밑변의 제곱 + 높이의 제곱
          // 거리 = 루트(밑변의 제곱 + 높이의 제곱)
          return Math.sqrt(Math.pow((x2 - x1),2)+Math.pow((y2 - y1),2));
        },
        // 두 점 사이의 각도
        getAngle(x1, y1, x2, y2, rotate){
          return (Math.atan2((y2 - y1), (x2 - x1)) * (180/Math.PI)) + (rotate||0);
        },
        // 특정 각도로 특정 길이만큼 이동했을 때 좌표
        getDistPos(dist, angle, x1, y1){
          const distX = (dist * Math.cos(angle*(Math.PI/180)));
          const distY = (dist * Math.sin(angle*(Math.PI/180)));
          return {
            x: x1 + distX,
            y: y1 + distY,
            distX: distX,
            distY: distY,
            left: distX < 0,
            right: distX > 0,
            up: distY < 0,
            down: distY > 0,
          }
        },
        // 회전시키기
        setRotate(rotate, width, x1, y1, x2, y2){
          const angle = StageUtil.getAngle(x1, y1, x2, y2, rotate); // 각도
          const dist = StageUtil.getDistance(x1, y1, x1+(width/2), y1+(width/2)); // 거리
          return {
            x: x1 + (dist * Math.cos((angle * Math.PI/180))),
            y: y1 + (dist * Math.sin((angle * Math.PI/180))),
          }
        }
      }
    })();
  </script>
  <script type="text/javascript">
    function Player(canvas, settings){
      // Player Configurations
      const config = {
        _id: null,
        name: "Unknown",
        size: "middle", // [small, middle, large]
        inputType: "wasd", // wasd: Default, arrow
        shape: {
          type: "circle",
          color: "#000000"
        },
        pos: {
          x: 30,
          y: 30
        },
        status: {
          health: 100,
        }
      };
      if( settings ){
        Object.keys(settings).forEach((key)=>{
          const value = settings[key];
          config[key] = (
            !(value instanceof Array || value instanceof Player) && value instanceof Object
            ? Object.assign(config[key]||{}, value)
            : settings[key]
          );
        });
      }

      // Player ID
      this.getConfig = (k)=>(config[k]);
      this.setConfig = (k,v)=>(config[k]=v);
      this.getId = ()=>(config._id);
      this.getName = ()=>(config.name);

      // Instance
      const insts = {
        root: document.querySelector(config.rootElement)||document.body,
        canvas: canvas,
        ctx: (canvas ? canvas.getContext("2d") : null),
      }
      this.getInst = (k)=>(insts[k]);
      this.setInst = (k,v)=>(insts[k]=v);
      this.getRoot = (k)=>(insts.root);
      this.getCanvas = ()=>(insts.canvas);
      this.getCtx = ()=>(insts.ctx);
      this.setCtx = (v)=>(insts.ctx=v);

      // Status
      const status = {
        health: 100,
        jumpping: false
      }
      Object.assign(status, config.status);
      this.getStatus = (k)=>(status[k]);
      this.setStatus = (k,v)=>(status[k]=v);
      this.getHealth = ()=>(status.health);
      this.setHealth = (v)=>(status.health=v);

      // Shape
      const shape = {
        type: "circle", // rect, circle, triangle
        color: "#ffffff" , // black
        size: {
          width: 30,
          height: 30,
          radius: 15,
        }
      }
      Object.assign(shape, config.shape);
      if( !config.size || config.size === "large" ){
        shape.size = {
          width: 30,
          height: 30,
          radius: 15,
        }
      } else if ( config.size === "middle" ){
        shape.size = {
          width: 20,
          height: 20,
          radius: 10
        }
      } else if ( config.size === "small" ){
        shape.size = {
          width: 15,
          height: 15,
          radius: 7.5
        }
      }

      this.getShape = ()=>(shape.type);
      this.setShape = (v)=>(shape.type=v);
      this.getSize = ()=>(shape.size);
      this.setSize = (width,height)=>(shape.size = { width, height });
      this.getWidth = ()=>(shape.size.width);
      this.setWidth = (width)=>{
        shape.size.width = width;
        shape.size.radius = (width/2);
      };
      this.getHeight = ()=>(shape.size.height);
      this.setHeight = (height)=>(shape.size.height = height);
      this.getRadius = ()=>(shape.size.radius);
      this.setRadius = (v)=>(shape.size.radius=v);
      this.getColor = ()=>(shape.color);
      this.setColor = (v)=>(shape.color = v);

      // Position: Player
      const move = {
        speed: 5,
        pos: {
          x: 0, y: 0
        }
      }
      Object.assign(move.pos, config.pos);

      this.getPos = ()=>(move.pos);
      this.setPos = (x,y)=>(Object.assign(move.pos,{x,y}));
      this.getPosX = ()=>(move.pos.x);
      this.setposX = (x)=>(move.pos.x = x);
      this.getPosY = ()=>(move.pos.y);
      this.setposY = (y)=>(move.pos.y = y);
      this.getMoveSpeed = ()=>(move.speed);
      this.setMoveSpeed = (v)=>(move.speed=v);

      // Positions: Aim
      const aim = {
        size: 3,
        dist: {
          now: shape.size.width*2,
          min: 10,
          max: 200
        },
        pos: {
          x: 100, y: 100,
        }
      }
      this.getAimPos = ()=>(aim.pos);
      this.setAimPos = (x,y)=>(Object.assign(aim.pos,{x,y}));
      this.getAimPosX = ()=>(aim.pos.x);
      this.setAimPosX = (x)=>(aim.pos.x=x);
      this.getAimPosY = ()=>(aim.pos.y);
      this.setAimPosY = (y)=>(aim.pos.y=y);
      this.getAimDist = ()=>(aim.dist.now);
      this.setAimDist = (v)=>(aim.dist.now=v);
      this.getAimSize = ()=>(aim.size);
      this.setAimSize = (v)=>(aim.size=v);
      this.getAimDistMin = ()=>(aim.dist.min);
      this.getAimDistMax = ()=>(aim.dist.max);

      // Initialize
      return this.init();
    }
    Player.prototype = (()=>{
      const _init = (self)=>{
        /**
         * 실시간으로 움직이는 정보를 받을 수 있도록 Socket 처리
         * 1) Socket Connection
         * 2) Socket Event Emit
         * 3) Socket Event Receiver
         */

        // Player 그리기
        _draw(self);
      }
      
      // 원형 그리기
      const _drawCircle = (self, x, y, radius)=>{
        const ctx = self.getCtx();
        const color = self.getColor();
        const aimX = self.getAimPosX();
        const aimY = self.getAimPosY();
        const zeroX = x + radius;
        const zeroY = y + radius;

        const angle = StageUtil.getAngle(zeroX, zeroY, aimX, aimY);

        // 원형
        ctx.beginPath();
        ctx.arc(x + radius, y + radius, radius, angle, 360, 0);
        ctx.fillStyle = color;
        ctx.fill();
        ctx.closePath();
      }
      // 사각형 그리기
      const _drawRectangle = (self, x, y, width, height)=>{
        const ctx = self.getCtx();
        const color = self.getColor();
        const aimX = self.getAimPosX();
        const aimY = self.getAimPosY();
        const zeroX = x + (width / 2);
        const zeroY = y + (width / 2);

        const p1 = StageUtil.setRotate(0, width, zeroX, zeroY, aimX, aimY);
        const p2 = StageUtil.setRotate(90, width, zeroX, zeroY, aimX, aimY);
        const p3 = StageUtil.setRotate(180, width, zeroX, zeroY, aimX, aimY);
        const p4 = StageUtil.setRotate(270, width, zeroX, zeroY, aimX, aimY);

        // 사각형
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.lineTo(p3.x, p3.y);
        ctx.lineTo(p4.x, p4.y);
        ctx.fillStyle = color;
        ctx.fill();
        ctx.closePath();

        // 전면 포인트
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.arc(p1.x, p1.y, 2, 0, Math.PI*2, 0);
        ctx.fillStyle = "blue";
        ctx.fill();
        ctx.closePath();
      }
      // 삼각형 그리기
      const _drawTriangle = (self, x, y, width, height)=>{
        const ctx = self.getCtx();
        const color = self.getColor();
        const aimX = self.getAimPosX();
        const aimY = self.getAimPosY();
        const zeroX = x + (width / 2);
        const zeroY = y + (width / 2);

        const p1 = StageUtil.setRotate(0, width, zeroX, zeroY, aimX, aimY);
        const p2 = StageUtil.setRotate(140, width, zeroX, zeroY, aimX, aimY);
        const p3 = StageUtil.setRotate(-140, width, zeroX, zeroY, aimX, aimY);

        // 삼각형
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.lineTo(p3.x, p3.y);
        ctx.fillStyle = color;
        ctx.fill();
        ctx.closePath();

        // 전면 포인트
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.arc(p1.x, p1.y, 2, 0, Math.PI*2, 0);
        ctx.fillStyle = "blue";
        ctx.fill();
        ctx.closePath();
      }
      // 텍스트 그리기
      const _drawText = (self, text, x, y)=>{
        const ctx = self.getCtx();
        const color = self.getColor();

        ctx.beginPath();
        ctx.font = "13px Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.direction = "inherit";
        ctx.fillStyle = color;
        ctx.fillText(text, x, y);
        ctx.closePath();
      }

      // 체력바 그리기
      const _drawHealthBar = (self, x, y, width, height)=>{
        const ctx = self.getCtx();
        const maxHealth = width+20;

        let color = "green";
        let health = maxHealth-((maxHealth/100)*(100-self.getHealth()));
        if( health <= 0 ){
          health = 0;
        }
        let healthGauge = (health/maxHealth)*100;
        if( healthGauge < 25 ){
          color = "red";
        } else if( healthGauge < 50 ){
          color = "yellow"
        }

        ctx.beginPath();
        ctx.rect(x-10, y-10, health < 0 ? 0 : health, 5);
        ctx.fillStyle = color;
        ctx.fill();
        ctx.rect(x-10, y-10, width+20, 5);
        ctx.strokeStyle = "black";
        ctx.stroke();
        ctx.closePath();
      }
      
      // 조준점 그리기
      const _drawAiming = (self)=>{
        const ctx = self.getCtx();

        const width = self.getWidth();
        const height = self.getHeight();
        const radius = self.getRadius();
        const posX = self.getPosX() + radius;
        const posY = self.getPosY() + radius;

        const aimSize = self.getAimSize();
        const aimPosX = self.getAimPosX();
        const aimPosY = self.getAimPosY();
        const aimDist = self.getAimDist();
        const aimAngle = StageUtil.getAngle(posX, posY, aimPosX, aimPosY);

        const crntAimPos = StageUtil.getDistPos(aimDist, aimAngle, posX, posY);
        const crntAimPosX = crntAimPos.x;
        const crntAimPosY = crntAimPos.y;

        // Aiming 표시
        ctx.beginPath();
        ctx.setLineDash([]);
        ctx.moveTo(crntAimPosX, crntAimPosY);
        ctx.arc(crntAimPosX, crntAimPosY, aimSize, 0, Math.PI*2, 0);
        ctx.fillStyle = "blue";
        ctx.fill();
        ctx.closePath();

        // Aiming 범위 표시
        ctx.beginPath();
        ctx.setLineDash([width/3,width]);
        ctx.arc(posX, posY, aimDist, 0, Math.PI*2, 0);
        ctx.strokeStyle = "red";
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.closePath();

        // Aiming Line 표시
        ctx.beginPath();
        ctx.setLineDash([5,5]);
        ctx.moveTo(posX, posY);
        ctx.arc(posX, posY, 1, 0, Math.PI*2, 0);
        ctx.lineTo(crntAimPosX, crntAimPosY);
        ctx.strokeStyle = "lightgrey";
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.closePath();
      }

      // 가이드라인 출력
      const _drawGuideLine = (self)=>{
        const ctx = self.getCtx();
        const color = "red";
        
        const width = self.getWidth();
        const height = self.getHeight();
        const radius = self.getRadius();

        const posX = self.getPosX();
        const posY = self.getPosY();
        const aimX = self.getAimPosX();
        const aimY = self.getAimPosY();

        // 십자모양 출력
        ctx.beginPath();
        ctx.moveTo(posX, posY + radius);
        ctx.lineTo(posX + width, posY + radius);  // 가로선
        ctx.moveTo(posX + radius, posY);
        ctx.lineTo(posX + radius, posY + height); // 세로선
        ctx.moveTo(posX + radius, posY + radius);
        ctx.arc(posX + radius, posY + radius, radius, 0, Math.PI * 2, 0);
        ctx.strokeStyle = color;
        ctx.stroke();
        ctx.closePath();
      }
      
      // Player 그리기
      const _drawPlayer = (self)=>{
        const shape = self.getShape();
        const name = self.getName()||"Unknown";

        const width = self.getWidth();
        const height = self.getHeight();
        const radius = self.getRadius();
        const posX = self.getPosX();
        const posY = self.getPosY();

        switch( shape ){
          case "circle": // 원형
            _drawCircle(self, posX, posY, radius);
            break;

          case "triangle": // 삼각형
            _drawTriangle(self, posX, posY, width, height);
            break;

          case "rect": // 사각형: Default
          default:
            _drawRectangle(self, posX, posY, width, height);
        }

        // 이름 표시
        _drawText(self, name, posX + radius, posY - 20);

        // 체력 게이지 표시
        _drawHealthBar(self, posX, posY, width, height);
      }

      const _draw = (self)=>{
        _drawPlayer(self); // Player 그리기
        _drawAiming(self); // Aiming 그리기
        _drawGuideLine(self); // Guide 그리기
      }

      return {
        init(){
          _init(this);
          return this;
        },
        draw(){
          _draw(this);
          return this;
        },
      }
    })();
  </script>
  <script type="text/javascript">
    function StageManager(canvas, settings){
      const config = {
        size: {
          width: 500,
          height: 500,
        }
      }
      if( settings ){
        Object.keys(settings).forEach((key)=>{
          const value = settings[key];
          config[key] = (
            !(value instanceof Array) && value instanceof Object
            ? Object.assign(config[key]||{}, value)
            : settings[key]
          );
        });
      }

      // Configurations
      this.getConfig = (k)=>(config[k]);
      this.setConfig = (k,v)=>(config[k]=v);

      // Instance
      const insts = {
        root: document.body,
        canvas: canvas
      }
      this.getInst = (k)=>(insts[k]);
      this.setInst = (k,v)=>(insts[k]=v);
      this.getRoot = ()=>(insts.root);
      this.getCanvas = ()=>(insts.canvas);
      this.setCanvas = (v)=>(insts.canvas=v);
      this.getCtx = ()=>(insts.ctx);
      this.setCtx = (v)=>(insts.ctx=v);

      // State
      const state = {
        players: 0,
        drawing: false,
      }
      this.getState = (k)=>(state[k]);
      this.setState = (k,v)=>(state[k] = v);

      // Players
      const player = {
        me: null,
        others: [],
      }
      this.getPlayer = ()=>(player.me);
      this.setPlayer = (v)=>(player.me=v);
      this.getPlayers = ()=>(player.others);
      this.setPlayers = (v)=>(player.others=v);
      this.addPlayer = (v)=>{
        player.others.push(v);
        state.players = player.others.length;
      };

      // Shape
      const shape = {
        size: {
          width: 500,
          height: 500,
        }
      }
      Object.assign(shape.size, config.size);
      this.getSize = ()=>(shape.size);
      this.setSize = (v)=>(Object.assign(shape.size, v));
      this.getWidth = ()=>(shape.size.width);
      this.getHeight = ()=>(shape.size.height);

      // Positions: pointer
      const pointer = {
        pressed: false,
        pos: {
          x: 0,
          y: 0
        }
      }
      this.getPointerPos = ()=>(pointer.pos);
      this.setPointerPos = (x,y)=>(Object.assign(pointer.pos,{x,y}));
      this.getPointerPosX = ()=>(pointer.pos.x);
      this.setPointerX = (x)=>(pointer.pos.x=x);
      this.getPointerPosY = ()=>(pointer.pos.y);
      this.setPointerY = (y)=>(pointer.pos.y=y);
      this.pointerDown = ()=>(pointer.pressed=true);
      this.pointerUp = ()=>(pointer.pressed=false);
      this.pointerPressed = ()=>(pointer.pressed);

      // Keyboard Pressed
      const pressKeys = {};
      this.keyboardPressed = (k)=>( k ? k in pressKeys : Object.keys(pressKeys).length > 0 );
      this.keyboardDown = (k)=>(pressKeys[k]=true);
      this.keyboardUp = (k)=>(delete pressKeys[k]);
      
      // Keyboard Codes
      this.KEYCODE = {
        "ARROW_LEFT": 37,
        "ARROW_UP": 38,
        "ARROW_RIGHT": 39,
        "ARROW_DOWN": 40,
        "A": 65,
        "W": 87,
        "D": 68,
        "S": 83,
      }
      this.KEYCODE_ARROW = {
        "LEFT": this.KEYCODE.ARROW_LEFT,
        "UP": this.KEYCODE.ARROW_UP,
        "RIGHT": this.KEYCODE.ARROW_RIGHT,
        "DOWN": this.KEYCODE.ARROW_DOWN,
      }
      this.KEYCODE_WASD = {
        "LEFT": this.KEYCODE.A,
        "UP": this.KEYCODE.W,
        "RIGHT": this.KEYCODE.D,
        "DOWN": this.KEYCODE.S,
      }
      this.getKeyCode = (k)=>(
        (k||"wasd").toLowerCase() === "wasd"
        ? this.KEYCODE_WASD
        : this.KEYCODE_ARROW 
      );

      return this.init();
    }
    StageManager.prototype = (()=>{
      const _init = (self, settings) => {
        // Canvas 초기 설정
        _initCanavs(self);
        
        // Event 바인딩
        _bindEvent(self);
      }

      /**
       * 이벤트 바인딩
       * - keyDown: 키 입력 중
       * - keyUp: 키 입력 완료
       * - mousedown, touchstart: 포인터 입력 중
       * - mouseup, touchend: 포인터 입력 완료
       * - mousemove, touchemove: 포인터 이동
       */
      const _bindEvent = (self)=>{
        self.getRoot().addEventListener("keydown", (e)=>{ self.keyboardDown(e.keyCode); });
        self.getRoot().addEventListener("keyup", (e)=>{ self.keyboardUp(e.keyCode); });
        
        self.getRoot().addEventListener("mousedown", (e)=>{
          self.setPointerPos(e.offsetX, e.offsetY);
          self.pointerDown();
        });
        self.getRoot().addEventListener("mouseup", (e)=>{ self.pointerUp(); });
        self.getRoot().addEventListener("mousemove", (e)=>{ self.setPointerPos(e.offsetX, e.offsetY); });

        self.getRoot().addEventListener("touchstart", (e)=>{ 
          self.setPointerPos(
            e.touches[0].clientX - self.getCanvas().offsetLeft,
            e.touches[0].clientY - self.getCanvas().offsetTop
          );
          self.pointerDown();
        });
        self.getRoot().addEventListener("touchend", (e)=>{ self.pointerUp(); });
        self.getRoot().addEventListener("touchmove", (e)=>{ 
          self.setPointerPos(
            e.touches[0].clientX - self.getCanvas().offsetLeft,
            e.touches[0].clientY - self.getCanvas().offsetTop
          );
        });
      }
      
      // Canvas 설정
      const _initCanavs = (self)=>{
        const canvas = self.getCanvas();

        canvas.width = self.getWidth();
        canvas.height = self.getHeight();

        self.setCtx(canvas.getContext("2d"));
      }

      // Main Player 생성
      const _initPlayer = (self)=>{
      }
      
      // Player 위치 갱신
      const _updatePos = (self, player)=>{
        // Player 정보
        const moveInput = player.getConfig("inputType");
        const moveDist = player.getMoveSpeed();

        // 좌표
        let posX = player.getPosX();
        let posY = player.getPosY();

        // 좌표 최소/최대
        const limitPosX = [0, self.getWidth() - player.getWidth()];
        const limitPosY = [0, self.getHeight() - player.getHeight()];
        
        // 입력 키에 따른 좌표값 설정
        const KEYCODE = self.getKeyCode(moveInput);
        
        if( self.keyboardPressed(KEYCODE.RIGHT) ){ posX += moveDist; }
        if( self.keyboardPressed(KEYCODE.LEFT) ){ posX -= moveDist; }
        if( self.keyboardPressed(KEYCODE.DOWN) ){ posY += moveDist; }
        if( self.keyboardPressed(KEYCODE.UP) ){ posY -= moveDist; }

        // 좌표 최소/최대 설정
        if( posX < limitPosX[0] ){ posX = limitPosX[0]; }
        if( posY < limitPosY[0] ){ posY = limitPosY[0]; }
        if( posX > limitPosX[1] ){ posX = limitPosX[1]; }
        if( posY > limitPosY[1] ){ posY = limitPosY[1]; }

        // 좌표로 설정
        player.setPos(posX, posY);
      }

      // Player Pointer Pos
      const _updatePointer = (self, player)=>{
        // 이동거리
        const moveDist = player.getMoveSpeed();

        // 좌표값
        const pointerPosX = self.getPointerPosX();
        const pointerPosY = self.getPointerPosY();
        let posX = player.getPosX();
        let posY = player.getPosY();

        // 조준점 좌표
        const aimPosX = player.getAimPosX();
        const aimPosY = player.getAimPosY();
        const aimAngle = StageUtil.getAngle(posX, posY, aimPosX, aimPosY);
        const aimDistPos = StageUtil.getDistPos(moveDist, aimAngle, posX, posY);

        // 좌표 최소/최대
        const limitPosX = [0, self.getWidth() - player.getWidth()];
        const limitPosY = [0, self.getHeight() - player.getHeight()];

        // 마우스,터치 입력 상태에 따른 좌표값 설정
        if( self.pointerPressed() && !self.keyboardPressed() ){
          // 조준 범위 바깥에만 클릭 가능(왼쪽, 오른쪽)
          if(( aimDistPos.left && aimPosX - moveDist > pointerPosX )|| // aim > pointer
             ( aimDistPos.right && aimPosX + moveDist < pointerPosX ))  // aim < pointer
            {
            posX += aimDistPos.distX;
          }
          // 조준 범위 바깥에만 클릭 가능(위쪽, 아래쪽)
          if(( aimDistPos.up && aimPosY - moveDist > pointerPosY )|| // aim < pointer
             ( aimDistPos.down && aimPosY + moveDist < pointerPosY ))  // aim > pointer
            {
            posY += aimDistPos.distY;
          }
        }

        // 좌표 최소/최대 설정
        if( posX < limitPosX[0] ){ posX = limitPosX[0]; }
        if( posY < limitPosY[0] ){ posY = limitPosY[0]; }
        if( posX > limitPosX[1] ){ posX = limitPosX[1]; }
        if( posY > limitPosY[1] ){ posY = limitPosY[1]; }

        // 좌표로 설정
        player.setPos(posX, posY);
      }

      // Player Pointer Pos
      const _followTarget = (self, player, target)=>{
        // 이동거리
        const moveDist = player.getMoveSpeed();
        
        // 좌표
        const posX = player.getPosX();
        const posY = player.getPosY();

        // Target 정보
        let targetPosX = self.getPointerPosX();
        let targetPosY = self.getPointerPosY();
        if( target instanceof Player ){
          targetPosX = target.getPosX();
          targetPosY = target.getPosY();
        }
        
        const targetAngle = StageUtil.getAngle(posX, posY, targetPosX, targetPosY);
        const targetDistPos = StageUtil.getDistPos(moveDist, targetAngle, posX, posY);

        // 좌표 설정
        player.setPos(targetDistPos.x, targetDistPos.y);
        player.setAimPos(targetPosX, targetPosY);
      }

      // 조준점 좌표 갱신
      const _updateAim = (self, player)=>{
        // 좌표
        const pointerPosX = self.getPointerPosX();
        const pointerPosY = self.getPointerPosY();
        const posX = player.getPosX() + player.getRadius();
        const posY = player.getPosY() + player.getRadius();

        // 조준점 좌표
        const aimDist = player.getAimDist();
        const aimAngle = StageUtil.getAngle(posX, posY, pointerPosX, pointerPosY);
        const aimX = posX + (aimDist * Math.cos(aimAngle*(Math.PI/180)));
        const aimY = posY + (aimDist * Math.sin(aimAngle*(Math.PI/180)));
        
        // 조준점 좌표 설정
        player.setAimPos(aimX, aimY);
      }

      // Stage 그리기
      const _drawStage = (self)=>{
        const ctx = self.getCtx();
        const width = self.getWidth();
        const height = self.getHeight();
        const pointerPosX = self.getPointerPosX();
        const pointerPosY = self.getPointerPosY();

        // Background 그리기
        ctx.beginPath();
        ctx.strokeStyle = "#000000";
        ctx.rect(0, 0, width, height);
        ctx.stroke();
        ctx.closePath();
        
        // Pointer 그리기
        ctx.beginPath();
        ctx.fillStyle = "red";
        ctx.setLineDash([]);
        ctx.moveTo(pointerPosX, pointerPosY);
        ctx.arc(pointerPosX, pointerPosY, 5, 0, Math.PI*2, 0);
        ctx.fill();
        ctx.closePath();
      }

      // Player 그리기
      const _drawPlayers = (self)=>{
        const player = self.getPlayer();
        _updatePos(self, player); // 위치 갱신
        _updateAim(self, player); // 조준점 갱신
        _updatePointer(self, player); // 포인터 갱신
        player.draw();

        const objs = self.getPlayers();
        for(let idx=0; idx<objs.length; idx++){
          const obj = objs[idx];

          // Target 따라가기
          const follow = obj.getConfig("follow");
          if( follow ) {
            _followTarget(self, obj, follow);
          }
          
          // 충돌감지
          if( StageUtil.getDistance(player.getPosX(), player.getPosY(), obj.getPosX(), obj.getPosY())
              < player.getRadius()
            ){
            player.setHealth(player.getHealth()-1); 
          }
          
          // 충돌감지(Bullet 만들기)
          if( StageUtil.getDistance(obj.getPosX(), obj.getPosY(), player.getPosX(), player.getPosY())
              < obj.getRadius()
            ){
            const objHealth = obj.getHealth()-10;
            obj.setHealth(objHealth);
            if( objHealth <= 0){
              delete objs[idx];
            }
          }
          // Object 그리기
          obj.draw();
        }
        self.setPlayers(objs.filter((o)=>(o)));
      }

      // Canvas 그리기 이벤트
      const _draw = (self)=>{
        // Canvas 그리기 서브 이벤트
        function drawer(){
          _clear(self); // Canvas 초기화

          _drawStage(self); // Stage 그리기
          _drawPlayers(self); // Player 그리기

          // 현재 상태 저장
          self.setState("drawing", requestAnimationFrame(drawer));
        }
        // 그리는 중인 경우 중단
        cancelAnimationFrame(self.getState("drawing"));
        self.setState("drawing", null);
        
        // 그리기 시작
        drawer();
      }

      // Canvas 초기화 이벤트
      const _clear = (self)=>{
        self.getCtx().clearRect(0,0,self.getWidth(),self.getHeight());
      }

      // 시작 이벤트
      const _start = (self)=>{
        const isDrawing = self.getState("drawing");
        if( !isDrawing ){
          _draw(self);
        }
      }

      // 중단 이벤트
      const _stop = async (self)=>{
        const drawing = self.getState("drawing");
        if( drawing ){
          await cancelAnimationFrame(drawing);
          self.setState("drawing", null);
        }
      }

      // 종료 이벤트
      const _destroy = async (self)=>{
        await _stop(self);
        await _clear(self);
        /**
         *  @TODO: 플레이어 데이터 삭제
        const players = self.getPlayers();
        players.forEach((player)=>{
          player.destroy();
        });
        */
      }
      
      return {
        init(settings){
          _init(this, settings);
          return this;
        },
        start(){
          _start(this);
        },
        stop(){
          _stop(this);
        },
        destroy(){
          _destroy(this);
        }
      }
    })();

    const canvas = document.querySelector("canvas#canvas-playground");
    const player = new Player(
      canvas,
      {
        name: "me",
        size: "large",
        shape: {
          type: "triangle",
          color: "grey",
        },
        // spawn
        /*
        pos: {
          x: stage.getWidth()/2,
          y: stage.getHeight()/2,
        },
        */
      }
    );
    const stage = new StageManager(
      canvas, 
      { 
        size: { 
          width: (window.screen.width/5)*4, 
          height: (window.screen.height/5)*3
        }
      }
    );
    stage.setPlayer(player);
    stage.start();

  </script>
  <script>

    // setInterval(addPlayer, Math.random()*1000);

    function addPlayer(){
      const randToggle = parseInt(Math.random()*1.5);
      const randPos = {
        x: ( randToggle === 0 ? Math.random()*stage.getWidth() : stage.getWidth() ),
        y: ( randToggle === 0 ? stage.getHeight() : Math.random()*stage.getHeight() ),
      }
      const NPC = new Player(
        stage.getCanvas(),
        {
          name: "NPC-"+(stage.getPlayers().length+1),
          inputType: document.querySelector("[name=inputType]").value,
          size: "small",
          follow: stage.getPlayer(),
          // follow: "pointer",
          shape: {
            type: document.querySelector("[name=shape]").value,
            color: document.querySelector("[name=color]").value,
          },
          pos: {
            x: randPos.x,
            y: randPos.y,
          },
        }
      );
      NPC.setMoveSpeed(Math.random()*3+1);

      stage.addPlayer(NPC);
    }
  </script>
  <script type="text/javascript">
    document.querySelector("#addPlayer").addEventListener("click", (e)=>{
      e.preventDefault();
      addPlayer();
      return false;
    });
    document.body.addEventListener("keydown", (e)=>{
      if( e.keyCode === 32 /* SpaceBar */ ){
        const triggerElement = document.querySelector("#addPlayer");
        const triggerEventType = "click";
        if( typeof document.createEvent === "function" ){
          // IE9+ and other modern browsers
          const triggerEvent = document.createEvent('HTMLEvents');
          triggerEvent.initEvent(triggerEventType, false, true);
          triggerElement.dispatchEvent(triggerEvent); 
        } else {
          // IE8
          const triggerEvent = document.createEventObject();
          triggerEvent.eventType = triggerEventType;
          triggerElement.fireEvent('on' + triggerEvent.eventType, e);
        }
      }
    });
    document.querySelector("#stop").addEventListener("click", (e)=>{
      e.preventDefault();
      stage.stop();
    });
    document.querySelector("#reset").addEventListener("click", (e)=>{
      e.preventDefault();
      stage.init();
    });
    document.querySelector("#destroy").addEventListener("click", (e)=>{
      e.preventDefault();
      stage.destroy();
    });
  </script>
</body>
</html>