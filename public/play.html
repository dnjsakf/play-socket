<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style type="text/css">
    * { box-sizing: border-box; padding: 0; margin: 0; user-select: none; touch-action: none; }
  </style>
</head>
<body>
  <div>
    <select name="inputType">
      <option value="wasd">WASD</option>
      <option value="arrow">방향키</option>
    </select>
    , shape: 
    <select name="shape">
      <option value="rect">사각형</option>
      <option value="triangle">삼각형</option>
      <option value="circle">원형</option>
      <option value="image">이미지</option>
    </select>
    , color: 
    <select name="color">
      <option value="red">red</option>
      <option value="blue">blue</option>
      <option value="green">green</option>
    </select>
    <button id="addPlayer">+</button>
    <button id="stop">stop</button>
    <button id="reset">reset</button>
    <button id="destroy">destroy</button>
  </div>
  <div>
    <canvas id="canvas-playground"></canvas>
  </div>
  <script type="text/javascript">
    function StageUtil(){}
    StageUtil = (()=>{
      return {
        // 두 점 사이의 거리
        getDistance(x1, y1, x2, y2){
          // 거리의 제곱 = 밑변의 제곱 + 높이의 제곱
          // 거리 = 루트(밑변의 제곱 + 높이의 제곱)
          return Math.sqrt(Math.pow((x2 - x1),2)+Math.pow((y2 - y1),2));
        },
        // 두 점 사이의 각도
        getAngle(x1, y1, x2, y2, rotate){
          return (Math.atan2((y2 - y1), (x2 - x1)) * (180/Math.PI)) + (rotate||0);
        },
        // 사분면
        getQuadrant(angle){
          if( Math.abs(angle) <= 90 ){
            if( angle >= 0 ){  // 4사분면
              return 4;
            } else { // 1사분면
              return 1;
            }
          } else if( Math.abs(angle) <= 180  ){ // 3사분면
            if( angle >= 0 ){  // 3사분면
              return 3;
            } else { // 2사분면
              return 2;
            }
          }
          return 0;
        },
        // 특정 각도로 특정 길이만큼 이동했을 때 좌표
        getMovePos(distance, angle, x1, y1){
          const vectorX = (distance * Math.cos(angle*(Math.PI/180)));
          const vectorY = (distance * Math.sin(angle*(Math.PI/180)));
          return {
            x: x1 + vectorX,
            y: y1 + vectorY,
            vectorX: vectorX,
            vectorY: vectorY,
            left: vectorX < 0,
            right: vectorX > 0,
            up: vectorY < 0,
            down: vectorY > 0,
          }
        },
        // 회전시키기
        setRotate(rotate, width, x1, y1, x2, y2){
          const angle = StageUtil.getAngle(x1, y1, x2, y2, rotate); // 각도
          const dist = StageUtil.getDistance(x1, y1, x1+(width/2), y1+(width/2)); // 거리
          return {
            x: x1 + (dist * Math.cos((angle * Math.PI/180))),
            y: y1 + (dist * Math.sin((angle * Math.PI/180))),
          }
        }
      }
    })();
    function DrawObject(ctx, settings){
      const config = {
        shape: "rect",
        zero: "normal",
        text: null,
        textAlign: "top",
        position: [ // [[x1,y1],[x2,y2]]
          [0, 0]
        ],
        style: {
          type: "fill",
          color: "#000000",
        },
        size: { 
          width: null,
          height: null,
          radius: null
        },
        guide: {
          show: false,
          size: 5,
          range: 100,
          visible: {
            radius: true,
            frontPoint: true,
            rangePoint: true,
            rangeRadius: true,
            rangeLine: true,
            destination: true,
          },
        },
      };
      if( settings ){
        function _extends(src, tgt){
          Object.keys(tgt).forEach((key)=>{
            let value = tgt[key];
            if( !(value instanceof Array) && value instanceof Object ){
              _extends(src[key], value);
            } else {
              src[key] = value;
            }
          });
        }
        _extends(config, settings);
      }

      this.getCtx = ()=>(ctx);

      this.getConfig = (k,v)=>(config[k]||v);
      this.setConfig = (k,v)=>(config[k]=v);
      this.getPos = ()=>(config.position);
      this.setPos = (v)=>(config.position=v);
      this.getStyle = (k,v)=>(config.style[k]||v);
      this.setStyle = (k,v)=>(config.style[k]=v);
      this.getSize = ()=>(config.size);
      this.setSize = (v)=>(config.size=v);
      this.getVisible = (k,v)=>(config.visible[k]||v);
      this.setVisible = (k,v)=>(config.visible[k]=v);

      this.getWidth = (v)=>(config.size.width||v);
      this.setWidth = (v)=>(config.size.width=v);
      this.getHeight = (v)=>(config.size.height||v);
      this.setHeight = (v)=>(config.size.height=v);
      this.getRadius = (v)=>(config.size.radius||v);
      this.setRadius = (v)=>(config.size.radius=v);
      
      this.getDrawStyle = (v)=>(config.style.type||v);
      this.setDrawStyle = (v)=>(config.style.type=v);
      this.getShape = (v)=>(config.shape||v);
      this.setShape = (v)=>(config.shape=v);
      this.getColor = (v)=>(config.style.color||v);
      this.setColor = (v)=>(config.style.color=v);

      this.getText = (v)=>(config.text||v);
      this.setText = (v)=>(config.text=v);
      this.getTextAlign = (v)=>(config.textAlign||v);
      this.setTextAlign = (v)=>(config.textAlign=v);
      
      return this.init();
    }
    DrawObject.prototype = (()=>{

      function _preDraw(self){
        const ctx = self.getCtx();
        ctx.beginPath();
      }

      function _postDraw(self){
        const ctx = self.getCtx();
        const style = self.getDrawStyle("fill");
        const color = self.getColor("#000000");

        if( style === "stroke" ){
          ctx.strokeStyle = color;
          ctx.stroke();
        } else {
          ctx.fillStyle = color;
          ctx.fill();
        }
        ctx.closePath();
      }

      const _drawCircle = (self, x1, y1, radius) => {
        const ctx = self.getCtx();
        
        _preDraw(self);
        ctx.arc(x1, y1, radius, 0, Math.PI * 2, 0);
        _postDraw(self);

        return { x1: x1, y1: y1 }
      }

      const _drawRectRotate = (self, x1, y1, x2, y2, width, height) => {
        const ctx = self.getCtx();
        const p1 = StageUtil.setRotate(0, width, x1, y1, x2, y2);
        const p2 = StageUtil.setRotate(90, width, x1, y1, x2, y2);
        const p3 = StageUtil.setRotate(180, width, x1, y1, x2, y2);
        const p4 = StageUtil.setRotate(270, width, x1, y1, x2, y2);
        
        _preDraw(self);
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.lineTo(p3.x, p3.y);
        ctx.lineTo(p4.x, p4.y);
        _postDraw(self);

        return {
          x1: p1.x, y1: p1.y,
          x2: p2.x, y2: p2.y,
          x3: p3.x, y3: p3.y,
          x4: p4.x, y4: p4.y
        }
      }

      const _drawTriangleRotate = (self, x1, y1, x2, y2, width, height) => {
        const ctx = self.getCtx();
        const p1 = StageUtil.setRotate(0, width, x1, y1, x2, y2);
        const p2 = StageUtil.setRotate(140, width, x1, y1, x2, y2);
        const p3 = StageUtil.setRotate(-140, width, x1, y1, x2, y2);

        _preDraw(self);
         ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.lineTo(p3.x, p3.y);
        _postDraw(self);

        return {
          x1: p1.x, y1: p1.y,
          x2: p2.x, y2: p2.y,
          x3: p3.x, y3: p3.y
        }
      }

      const _drawText = (self, text, x1, y1) => {
        const ctx = self.getCtx();

        ctx.beginPath();
        ctx.font = "13px Arial";
        ctx.textAlign = "center";
        ctx.fillText(text, x1, y1);
        ctx.closePath();
      }

      const _drawProgress = (self, maxValue, val, x1, y1, width, height) => {
        const ctx = self.getCtx();

        let color = "green";
        let progress = (val/maxValue)*100;
        if( progress <= 0 ){
          progress = 0;
        } else if( progress < 25 ){
          color = "red";
        } else if( progress < 50 ){
          color = "yellow"
        } else {
          color = "green";
        }

        ctx.beginPath();
        ctx.rect(x1, y1, width*(progress/100), height);
        ctx.fillStyle = color;
        ctx.fill();
        ctx.closePath();

        ctx.beginPath()
        ctx.rect(x1, y1, width, height);
        ctx.strokeStyle = "black";
        ctx.stroke();
        ctx.closePath();

        ctx.beginPath()
        ctx.font = "6px Arial";
        ctx.textAlign = "center";
        ctx.fillStyle = "black";
        ctx.fillText(progress+"%", x1+(width/2), y1+6);
        ctx.closePath();
      }

      const _drawGuide = (self, size, range, x1, y1, x2, y2, radius, visible) => {
        const ctx = self.getCtx();

        const gudieAngle = StageUtil.getAngle(x1, y1, x2, y2);
        const guidePos = StageUtil.getMovePos(range, gudieAngle, x1, y1);
        const guidePosX = guidePos.x;
        const guidePosY = guidePos.y;
        
        // 회전 반경
        if( visible.radius ){
          ctx.beginPath();
          ctx.moveTo(x1 - radius, y1);
          ctx.lineTo(x1 + radius, y1);  // 가로선
          ctx.moveTo(x1, y1 - radius);
          ctx.lineTo(x1, y1 + radius); // 세로선
          ctx.moveTo(x1, y1);
          ctx.arc(x1, y1, radius, 0, Math.PI * 2, 0);
          ctx.strokeStyle = "blue";
          ctx.stroke();
          ctx.closePath();
        }
        
        // 전면 Point 표시
        if( visible.frontPoint ){
          ctx.beginPath();
          ctx.arc(x2, y2, size, 0, Math.PI*2, 0);
          ctx.fillStyle = "blue";
          ctx.fill();
          ctx.closePath();
        }

        // 가이드 point 표시
        if( visible.rangePoint ){
          ctx.beginPath();
          ctx.arc(guidePosX, guidePosY, size, 0, Math.PI * 2, 0);
          ctx.fillStyle = "blue";
          ctx.fill();
          ctx.closePath();
        }

        // 가이드 범위 표시
        if( visible.rangeRadius ){
          ctx.beginPath();
          ctx.setLineDash([15,10]);
          ctx.arc(x1, y1, range, 0, Math.PI * 2, 0);
          ctx.strokeStyle = "red";
          ctx.stroke();
          ctx.setLineDash([]);
          ctx.closePath();
        }

        // 가이드 Line 표시
        if( visible.rangeLine ){
          ctx.beginPath();
          ctx.setLineDash([5,5]);
          ctx.moveTo(x1, y1);
          ctx.lineTo(guidePosX, guidePosY);
          ctx.strokeStyle = "red";
          ctx.stroke();
          ctx.setLineDash([]);
        }

        // 목적지 Line 표시
        if( visible.destination ){
          ctx.beginPath();
          ctx.setLineDash([5,5]);
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);
          ctx.strokeStyle = "red";
          ctx.stroke();
          ctx.setLineDash([]);
          ctx.closePath();
        }
      }

      return {
        init(){
          return this;
        },
        draw(data){
          const ctx = this.getCtx();
          const pos = this.getPos();

          const width = this.getWidth();
          const height = this.getHeight();
          const radius = this.getRadius(width/2);

          let x1, y1, x2, y2, x3, y3;

          if( pos.length > 0 ){
            x1 = pos[0][0];
            y1 = pos[0][1];
          }
          if( pos.length > 1 ){
            x2 = pos[1][0];
            y2 = pos[1][1];
          }
          
          switch(this.getConfig("zero", "normal")){
            case "middle":
              x1 += radius;
              y1 += radius;
              break;
            case "normal":
            default:
          }
          
          switch(this.getShape("rect")){
            case "cricle":
              const cricle = _drawCircle(this, x1, y1, radius);
              x3 = cricle.x1;
              y3 = cricle.y1;
              break;
            case "rect":
              const rect = _drawRectRotate(this, x1, y1, x2, y2, width, height);
              x3 = rect.x1;
              y3 = rect.y1;
              break;
            case "triangle":
              const triangle = _drawTriangleRotate(this, x1, y1, x2, y2, width, height);
              x3 = triangle.x1;
              y3 = triangle.y1;
              break;
            case "progress":
              const progress = _drawProgress(this, data.maxValue, data.value, x1-radius-10, y1-radius-13, width, 8);
              break;
          }
          
          const text = this.getText();
          if( text ){
            let tPosX = x1;
            let tPosY = y1;
            switch(this.getTextAlign("top")){
              case "left":
                tPosX -= (radius+20);
                break;
              case "top":
              default:
                tPosY -= (radius+20);
            }
            _drawText(this, text, tPosX, tPosY);
          }
          
          // 가이드 라인
          const guide = this.getConfig("guide");
          if( guide.show ){
            _drawGuide(this, guide.size, guide.range, x1, y1, x2, y2, radius, guide.visible);
          }
        },
      }
    })();
  </script>
  <script type="text/javascript">
    function Player(canvas, settings){
      // Player Configurations
      const config = {
        _id: null,
        name: "Unknown",
        size: "middle", // [small, middle, large]
        inputType: "wasd", // wasd: Default, arrow
        shape: {
          type: "circle",
          color: "#000000"
        },
        pos: {
          x: 30,
          y: 30
        },
        status: {
          health: 100,
        },
        guide: {
          show: false,
          size: 5,
          range: 100,
          visible: {
            radius: true,
            frontPoint: true,
            rangePoint: true,
            rangeRadius: true,
            rangeLine: true,
            destination: true,
          },
        }
      };
      if( settings ){
        function _extends(src, tgt){
          Object.keys(tgt).forEach((key)=>{
            let value = tgt[key];
            if( !(value instanceof Array || value instanceof Player) && value instanceof Object ){
              _extends(src[key], value);
            } else {
              src[key] = value;
            }
          });
        }
        _extends(config, settings);
      }

      // Player ID
      this.getConfig = (k)=>(config[k]);
      this.setConfig = (k,v)=>(config[k]=v);
      this.getId = ()=>(config._id);
      this.getName = ()=>(config.name);

      // Instance
      const insts = {
        canvas: canvas,
        ctx: (canvas ? canvas.getContext("2d") : null),
      }
      this.getInst = (k)=>(insts[k]);
      this.setInst = (k,v)=>(insts[k]=v);
      this.getCanvas = ()=>(insts.canvas);
      this.getCtx = ()=>(insts.ctx);
      this.setCtx = (v)=>(insts.ctx=v);

      // Status
      const status = {
        health: 100,
        jumpping: false
      }
      Object.assign(status, config.status);
      this.getStatus = (k)=>(status[k]);
      this.setStatus = (k,v)=>(status[k]=v);
      this.getHealth = ()=>(status.health);
      this.setHealth = (v)=>(status.health=v);

      // Shape
      const shape = {
        type: "circle", // rect, circle, triangle
        color: "#ffffff" , // black
        size: { width: 30, height: 30, radius: 15, }
      }
      Object.assign(shape, config.shape);
      if( !config.size || config.size === "large" ){
        shape.size = { width: 30, height: 30, radius: 15, }
      } else if ( config.size === "middle" ){
        shape.size = { width: 20, height: 20, radius: 10 }
      } else if ( config.size === "small" ){
        shape.size = { width: 15, height: 15, radius: 7.5 }
      }

      this.getShape = ()=>(shape.type);
      this.setShape = (v)=>(shape.type=v);
      this.getSize = ()=>(shape.size);
      this.setSize = (width,height)=>(shape.size = { width, height });
      this.getWidth = ()=>(shape.size.width);
      this.setWidth = (width)=>{
        shape.size.width = width;
        shape.size.radius = (width/2);
      };
      this.getHeight = ()=>(shape.size.height);
      this.setHeight = (height)=>(shape.size.height = height);
      this.getRadius = ()=>(shape.size.radius);
      this.setRadius = (v)=>(shape.size.radius=v);
      this.getColor = ()=>(shape.color);
      this.setColor = (v)=>(shape.color = v);

      // Position: Player
      const move = {
        speed: 5,
        pos: {
          x: 0, y: 0
        }
      }
      Object.assign(move.pos, config.pos);

      this.getPos = ()=>(move.pos);
      this.setPos = (x,y)=>{
        if( x ){ move.pos.x = x }
        if( y ){ move.pos.y = y }
      };
      this.getPosX = ()=>(move.pos.x);
      this.setposX = (x)=>(move.pos.x = x);
      this.getPosY = ()=>(move.pos.y);
      this.setposY = (y)=>(move.pos.y = y);
      this.getMoveSpeed = ()=>(move.speed);
      this.setMoveSpeed = (v)=>(move.speed=v);

      // Positions: Aim
      const aim = {
        size: 3,
        range: {
          now: 300,
          min: 300,
          max: 700
        },
        pos: {
          x: 100, y: 100,
        }
      }
      this.getAimPos = ()=>(aim.pos);
      this.setAimPos = (x,y)=>{
        if( x ){ aim.pos.x = x }
        if( y ){ aim.pos.y = y }
      };
      this.getAimPosX = ()=>(aim.pos.x);
      this.setAimPosX = (x)=>(aim.pos.x=x);
      this.getAimPosY = ()=>(aim.pos.y);
      this.setAimPosY = (y)=>(aim.pos.y=y);
      this.getAimRange = ()=>(aim.range.now);
      this.setAimRange = (v)=>(aim.range.now=v);
      this.getAimSize = ()=>(aim.size);
      this.setAimSize = (v)=>(aim.size=v);
      this.getAimRangeMin = ()=>(aim.range.min);
      this.getAimRangeMax = ()=>(aim.range.max);

      // Positions: HitBox
      const hitBox = [];
      this.getHitBox = ()=>(hitBox);
      this.addHitBox = (v)=>(hitBox.push(v));

      // Initialize
      return this.init();
    }
    Player.prototype = (()=>{
      // 초기값 설정
      const _init = (self)=>{
        const name = self.getName();
        const shape = self.getShape();
        const color = self.getColor();
        const width = self.getWidth();
        const height = self.getHeight();
        const radius = self.getRadius();
        const guide = self.getConfig("guide");

        if( guide.show ){
          guide.range = self.getAimRange();
        }

        self.setInst("playerDrawer", new DrawObject(
          self.getCtx(),
          {
            shape: shape,
            text: name,
            size: {
              width: width,
              height: height,
              radius: radius
            },
            style: {
              style: "fill",
              color: color,
            },
            guide: guide
          }
        ));

        self.setInst("healthDrwer", new DrawObject(
          self.getCtx(),
          {
            shape: "progress",
            size: {
              width: width+20,
              radius: radius,
            },
          }
        ));

        _draw(self); // Player 그리기
      }
      // Player 그리기
      const _draw = (self)=>{
        const pos = self.getPos();
        const aimPos = self.getAimPos();

        const playerDrawer = self.getInst("playerDrawer");
        playerDrawer.setPos([
          [pos.x, pos.y],
          [aimPos.x, aimPos.y]
        ]);
        playerDrawer.draw();
        
        const healthDrwer = self.getInst("healthDrwer");
        healthDrwer.setPos([
          [pos.x, pos.y],
        ]);
        healthDrwer.draw({
          maxValue: 100,
          value: self.getHealth()
        });
      }

      return {
        init(x,y){
          _init(this, x, y);
          return this;
        },
        draw(){
          _draw(this);
          return this;
        }
      }
    })();
  </script>
  <script type="text/javascript">
    function Bullet(canvas, settings){
      const config = {
        power: 10,
        speed: 5,
        distance: 200,
        size: 4,
      }
      if( settings ){
        function _extends(src, tgt){
          Object.keys(tgt).forEach((key)=>{
            let value = tgt[key];
            if( !(value instanceof Array || value instanceof Player) && value instanceof Object ){
              _extends(src[key], value);
            } else {
              src[key] = value;
            }
          });
        }
        _extends(config, settings);
      }

      this.getConfig = (k,v)=>(config[k]||v);
      this.setConfig = (k,v)=>(config[k]=v);

      this.getPlayer = ()=>(config.player);
      this.setPlayer = (v)=>(config.player=v);
      this.getPower = (v)=>(config.power||v);
      this.setPower = (v)=>(config.power=v);
      this.getSpeed = (v)=>(config.speed||v);
      this.setSpeed = (v)=>(config.speed=v);
      this.getDistance = (v)=>(config.distance||v);
      this.setDistance = (v)=>(config.distance=v);
      this.getSize = ()=>(config.size);
      this.setSize = (v)=>(config.size=v);

      const state = {
        isFired: false,
      }
      this.isFired = (v)=>{
        if( typeof v === "boolean" ){
          state.isFired = v;
        }
        return state.isFired;
      };

      const position = {
        angle: 0,
        current: {
          x: 0, y: 0
        },
        destination: {
          x: 0, y: 0
        }
      }
      this.getAngle = ()=>(position.angle);
      this.setAngle = (v)=>(position.angle=v);

      this.getPos = ()=>(position.current);
      this.setPos = (x,y)=>{
        if( x ){ position.current.x = x }
        if( y ){ position.current.y = y }
      };
      this.getPosX = ()=>(position.current.x);
      this.setPosX = (v)=>(position.current.x=v);
      this.getPosY = ()=>(position.current.y);
      this.setPosY = (v)=>(position.current.y=v);

      this.getDest = ()=>(position.destination);
      this.setDest = (x,y)=>{
        if( x ){ position.destination.x = x }
        if( y ){ position.destination.y = y }
      };
      this.getDestX = ()=>(position.destination.x);
      this.setDestX = (v)=>(position.destination.x=v);
      this.getDestY = ()=>(position.destination.y);
      this.setDestY = (v)=>(position.destination.y=v);

      // Instance
      const insts = {
        canvas: canvas,
        ctx: (canvas ? canvas.getContext("2d") : null),
      }
      this.getInst = (k)=>(insts[k]);
      this.setInst = (k,v)=>(insts[k]=v);
      this.getCanvas = ()=>(insts.canvas);
      this.getCtx = ()=>(insts.ctx);
      this.setCtx = (v)=>(insts.ctx=v);

      return this.init();
    }
    Bullet.prototype = (()=>{
      const _init = (self)=>{
      }

      const _draw = (self)=>{
        const ctx = self.getCtx();
        const x1 = Math.floor(self.getPosX());
        const y1 = Math.floor(self.getPosY());
        const size = self.getSize();

        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.arc(x1, y1, size, 0, Math.PI * 2, 0);
        ctx.fillStyle = "green";
        ctx.fill();
        ctx.closePath();
      }

      const _fire = (self, x1, y1, x2, y2)=>{
        const speed = self.getSpeed();
        const distance = self.getDistance();
        const angle = StageUtil.getAngle(x1, y1, x2, y2);

        self.isFired(true);
        self.setPos(x1, y1);

        const interval = setInterval(()=>{
          if( self.isFired() ){
            const move = StageUtil.getMovePos(speed, angle, self.getPosX(), self.getPosY());

            self.setPos(move.x, move.y);

            return self.isFired(StageUtil.getDistance(x1, y1, move.x, move.y) < distance);
          }
          clearInterval(interval);
        }, speed);
      }

      return {
        init(){
          _init(this);
          return this;
        },
        draw(){
          _draw(this);
          return this;
        },
        fire(x1, y1, x2, y2){
          _fire(this, x1, y1, x2, y2);
          return this;
        },
        colision(x1, y1, radius){
          if( StageUtil.getDistance(x1, y1, this.getPosX(), this.getPosY()) < this.getSize() + (radius||0)){
            this.isFired(false);
            return true;
          }
          return false;
        }
      }
    })();
  </script>
  <script type="text/javascript">
    function Spawn(canvas, settings){
      // 스폰 설정에 따라 생성되는 오브젝트의 크기, 
    }
  </script>
  <script type="text/javascript">
    function StageManager(canvas, settings){
      const config = {
        size: {
          width: 500,
          height: 500,
        }
      }
      if( settings ){
        function _extends(src, tgt){
          Object.keys(tgt).forEach((key)=>{
            let value = tgt[key];
            if( !(value instanceof Array) && value instanceof Object ){
              _extends(src[key], value);
            } else {
              src[key] = value;
            }
          });
        }
        _extends(config, settings);
      }

      // Configurations
      this.getConfig = (k)=>(config[k]);
      this.setConfig = (k,v)=>(config[k]=v);

      // Instance
      const insts = {
        root: document.body,
        canvas: canvas
      }
      this.getInst = (k)=>(insts[k]);
      this.setInst = (k,v)=>(insts[k]=v);
      this.getRoot = ()=>(insts.root);
      this.getCanvas = ()=>(insts.canvas);
      this.setCanvas = (v)=>(insts.canvas=v);
      this.getCtx = ()=>(insts.ctx);
      this.setCtx = (v)=>(insts.ctx=v);

      // State
      const state = {
        players: 0,
        drawing: false,
      }
      this.getState = (k)=>(state[k]);
      this.setState = (k,v)=>(state[k] = v);

      // Players
      const player = {
        me: null,
        others: [],
      }
      this.getPlayer = ()=>(player.me);
      this.setPlayer = (v)=>(player.me=v);
      this.getPlayers = ()=>(player.others);
      this.cleanPlayers = ()=>(player.others = player.others.filter((o)=>(o)));
      this.addPlayer = (v)=>{
        player.others.push(v);
        state.players = player.others.length;
      };

      // Bullets
      let bullets = [];
      this.getBullets = ()=>(bullets);
      this.cleanBullets = ()=>(bullets = bullets.filter((o)=>(o)));
      this.addBullets = (v)=>(bullets.push(v));

      // Shape
      const shape = {
        size: {
          width: 500,
          height: 500,
        }
      }
      Object.assign(shape.size, config.size);
      this.getSize = ()=>(shape.size);
      this.setSize = (v)=>(Object.assign(shape.size, v));
      this.getWidth = ()=>(shape.size.width);
      this.getHeight = ()=>(shape.size.height);

      // Positions: pointer
      const pointer = {
        pressed: false,
        pos: {
          x: 0,
          y: 0
        }
      }
      this.getPointerPos = ()=>(pointer.pos);
      this.setPointerPos = (x,y)=>{
        if( x ){ pointer.pos.x = x }
        if( y ){ pointer.pos.y = y }
      };
      this.getPointerPosX = ()=>(pointer.pos.x);
      this.setPointerX = (x)=>(pointer.pos.x=x);
      this.getPointerPosY = ()=>(pointer.pos.y);
      this.setPointerY = (y)=>(pointer.pos.y=y);
      this.pointerDown = ()=>(pointer.pressed=true);
      this.pointerUp = ()=>(pointer.pressed=false);
      this.pointerPressed = ()=>(pointer.pressed);

      // Keyboard Pressed
      const pressKeys = {};
      this.keyboardPressed = (k)=>( k ? k in pressKeys : Object.keys(pressKeys).length > 0 );
      this.keyboardDown = (k)=>(pressKeys[k]=true);
      this.keyboardUp = (k)=>(delete pressKeys[k]);
      this.getPressKeys = ()=>(pressKeys);
      
      // Keyboard Codes
      this.KEYCODE = {
        "ARROW_LEFT": 37,
        "ARROW_UP": 38,
        "ARROW_RIGHT": 39,
        "ARROW_DOWN": 40,
        "A": 65,
        "W": 87,
        "D": 68,
        "S": 83,
        "SPACE": 32,
        "F": 70,
      }
      this.KEYCODE_ARROW = {
        "LEFT": this.KEYCODE.ARROW_LEFT,
        "UP": this.KEYCODE.ARROW_UP,
        "RIGHT": this.KEYCODE.ARROW_RIGHT,
        "DOWN": this.KEYCODE.ARROW_DOWN,
        "SPACE": this.KEYCODE.SPACE
      }
      this.KEYCODE_WASD = {
        "LEFT": this.KEYCODE.A,
        "UP": this.KEYCODE.W,
        "RIGHT": this.KEYCODE.D,
        "DOWN": this.KEYCODE.S,
        "SPACE": this.KEYCODE.F
      }
      this.getKeyCode = (k)=>(
        (k||"wasd").toLowerCase() === "wasd"
        ? this.KEYCODE_WASD
        : this.KEYCODE_ARROW 
      );

      return this.init();
    }
    StageManager.prototype = (()=>{
      const _init = (self, settings) => {
        // Canvas 초기 설정
        _initCanavs(self);
        
        // Event 바인딩
        _bindEvent(self);
      }

      /**
       * 이벤트 바인딩
       * - keyDown: 키 입력 중
       * - keyUp: 키 입력 완료
       * - mousedown, touchstart: 포인터 입력 중
       * - mouseup, touchend: 포인터 입력 완료
       * - mousemove, touchemove: 포인터 이동
       */
      const _bindEvent = (self)=>{
        self.getRoot().addEventListener("keydown", (e)=>{ self.keyboardDown(e.keyCode); });
        self.getRoot().addEventListener("keyup", (e)=>{ self.keyboardUp(e.keyCode); });
        
        self.getRoot().addEventListener("mousedown", (e)=>{
          self.setPointerPos(e.offsetX, e.offsetY);
          self.pointerDown();
        });
        self.getRoot().addEventListener("mouseup", (e)=>{ self.pointerUp(); });
        self.getRoot().addEventListener("mousemove", (e)=>{ self.setPointerPos(e.offsetX, e.offsetY); });

        self.getRoot().addEventListener("touchstart", (e)=>{ 
          self.setPointerPos(
            e.touches[0].clientX - self.getCanvas().offsetLeft,
            e.touches[0].clientY - self.getCanvas().offsetTop
          );
          self.pointerDown();
        });
        self.getRoot().addEventListener("touchend", (e)=>{ self.pointerUp(); });
        self.getRoot().addEventListener("touchmove", (e)=>{ 
          self.setPointerPos(
            e.touches[0].clientX - self.getCanvas().offsetLeft,
            e.touches[0].clientY - self.getCanvas().offsetTop
          );
        });
      }
      
      // Canvas 설정
      const _initCanavs = (self)=>{
        const canvas = self.getCanvas();

        canvas.width = self.getWidth();
        canvas.height = self.getHeight();

        self.setCtx(canvas.getContext("2d"));
      }

      // Main Player 생성
      const _initPlayer = (self)=>{
      }
      
      // Player 위치 갱신
      const _updatePos = (self, player)=>{
        // Player 정보
        const moveDist = player.getMoveSpeed();

        // 좌표
        let posX = player.getPosX();
        let posY = player.getPosY();

        // 좌표 최소/최대
        const limitPosX = [0, self.getWidth() - player.getWidth()];
        const limitPosY = [0, self.getHeight() - player.getHeight()];
        
        // 입력 키에 따른 좌표값 설정
        const KEYCODE = self.getKeyCode(player.getConfig("inputType"));
        
        if( self.keyboardPressed(KEYCODE.RIGHT) ){ posX += moveDist; }
        if( self.keyboardPressed(KEYCODE.LEFT) ){ posX -= moveDist; }
        if( self.keyboardPressed(KEYCODE.DOWN) ){ posY += moveDist; }
        if( self.keyboardPressed(KEYCODE.UP) ){ posY -= moveDist; }

        // 좌표 최소/최대 설정
        if( posX < limitPosX[0] ){ posX = limitPosX[0]; }
        if( posY < limitPosY[0] ){ posY = limitPosY[0]; }
        if( posX > limitPosX[1] ){ posX = limitPosX[1]; }
        if( posY > limitPosY[1] ){ posY = limitPosY[1]; }

        // 좌표로 설정
        player.setPos(posX, posY);
      }

      // Player Pointer Pos
      const _updatePointer = (self, player)=>{
        // 이동거리
        const moveDist = player.getMoveSpeed();

        // 좌표값
        const pointerPosX = self.getPointerPosX();
        const pointerPosY = self.getPointerPosY();
        let posX = player.getPosX();
        let posY = player.getPosY();

        // 조준점 좌표
        const aimPosX = player.getAimPosX();
        const aimPosY = player.getAimPosY();
        const aimAngle = StageUtil.getAngle(posX, posY, aimPosX, aimPosY);
        const aimDistPos = StageUtil.getMovePos(moveDist, aimAngle, posX, posY);

        // 좌표 최소/최대
        const limitPosX = [0, self.getWidth() - player.getWidth()];
        const limitPosY = [0, self.getHeight() - player.getHeight()];

        // 마우스,터치 입력 상태에 따른 좌표값 설정
        if( self.pointerPressed() ){
          // 조준 범위 바깥에만 클릭 가능(왼쪽, 오른쪽)
          if(( aimDistPos.left && aimPosX - moveDist > pointerPosX )|| // aim > pointer
             ( aimDistPos.right && aimPosX + moveDist < pointerPosX ))  // aim < pointer
            {
            posX += aimDistPos.vectorX;
          }
          // 조준 범위 바깥에만 클릭 가능(위쪽, 아래쪽)
          if(( aimDistPos.up && aimPosY - moveDist > pointerPosY )|| // aim < pointer
             ( aimDistPos.down && aimPosY + moveDist < pointerPosY ))  // aim > pointer
            {
            posY += aimDistPos.vectorY;
          }
        }

        // 좌표 최소/최대 설정
        if( posX < limitPosX[0] ){ posX = limitPosX[0]; }
        if( posY < limitPosY[0] ){ posY = limitPosY[0]; }
        if( posX > limitPosX[1] ){ posX = limitPosX[1]; }
        if( posY > limitPosY[1] ){ posY = limitPosY[1]; }

        // 좌표로 설정
        player.setPos(posX, posY);
      }

      // Target 따라가기
      const _followTarget = (self, player, target)=>{
        // 이동거리
        const moveDist = player.getMoveSpeed();
        
        // 좌표
        const posX = player.getPosX();
        const posY = player.getPosY();

        // Target 정보
        let targetPosX = self.getPointerPosX();
        let targetPosY = self.getPointerPosY();
        if( target instanceof Player ){
          targetPosX = target.getPosX();
          targetPosY = target.getPosY();
        }
        
        const targetAngle = StageUtil.getAngle(posX, posY, targetPosX, targetPosY);
        const targetMovePos = StageUtil.getMovePos(moveDist, targetAngle, posX, posY);

        // 좌표 설정
        player.setPos(targetMovePos.x, targetMovePos.y);
        player.setAimPos(targetPosX, targetPosY);
      }

      // 조준점 좌표 갱신
      const _updateAim = (self, player)=>{
        // 좌표
        const pointerPosX = self.getPointerPosX();
        const pointerPosY = self.getPointerPosY();
        const posX = player.getPosX();
        const posY = player.getPosY();

        // 조준점 좌표
        const aimDist = player.getAimRange();
        const aimAngle = StageUtil.getAngle(posX, posY, pointerPosX, pointerPosY);
        const aimX = posX + (aimDist * Math.cos(aimAngle*(Math.PI/180)));
        const aimY = posY + (aimDist * Math.sin(aimAngle*(Math.PI/180)));
        
        // 조준점 좌표 설정
        player.setAimPos(aimX, aimY);
      }

      // 총알 생성
      const _updateBullet = (self, player)=>{
          
        // 입력 키에 따른 좌표값 설정
        const KEYCODE = self.getKeyCode(player.getConfig("inputType"));
        
        // 좌표
        let posX = player.getPosX();
        let posY = player.getPosY();
        let aimX = player.getAimPosX();
        let aimY = player.getAimPosY();

        // Space 입력
        // if( self.keyboardPressed(KEYCODE.SPACE) ){
        if( self.pointerPressed() ){
          const bullet = new Bullet(self.getCanvas(), {
            player: player,
            distance: player.getAimRange(),
          });
          bullet.fire(posX, posY, aimX, aimY);

          self.addBullets(bullet);

          return bullet;
        }
        return null;
      }

      // Stage 그리기
      const _drawStage = (self)=>{
        const ctx = self.getCtx();
        const width = self.getWidth();
        const height = self.getHeight();
        const pointerPosX = self.getPointerPosX();
        const pointerPosY = self.getPointerPosY();

        // Background 그리기
        ctx.beginPath();
        ctx.strokeStyle = "#000000";
        ctx.rect(0, 0, width, height);
        ctx.stroke();
        ctx.closePath();
        
        // Pointer 그리기
        ctx.beginPath();
        ctx.fillStyle = "red";
        ctx.setLineDash([]);
        ctx.moveTo(pointerPosX, pointerPosY);
        ctx.arc(pointerPosX, pointerPosY, 5, 0, Math.PI*2, 0);
        ctx.fill();
        ctx.closePath();
      }

      // Player 그리기
      const _drawPlayers = (self)=>{
        const player = self.getPlayer();
        const bullet = _updateBullet(self, player);  // 총알 발사
        _updatePos(self, player);     // 위치 갱신
        _updateAim(self, player);     // 조준점 갱신
        //_updatePointer(self, player); // 포인터 갱신
        player.draw();

        const players = self.getPlayers();
        const bullets = self.getBullets().filter((bullet)=>(bullet.isFired()));
        for(let idx=0; idx<players.length; idx++){
          const obj = players[idx];

          // Target 따라가기
          const follow = obj.getConfig("follow");
          if( follow ) {
            _followTarget(self, obj, follow);
          }
          
          // 충돌감지
          if( StageUtil.getDistance(follow.getPosX(), follow.getPosY(), obj.getPosX(), obj.getPosY()) < follow.getRadius()
            ){
            follow.setHealth(follow.getHealth()-1); 
            const objHealth = obj.getHealth()-10;
            if( objHealth <= 0){
              delete players[idx];
            }
            obj.setHealth(objHealth);
          }

          // 충돌감지(Bullet)
          for(let bulletIndex=0; bulletIndex < bullets.length; bulletIndex++){
            const colision = bullets[bulletIndex].colision(obj.getPosX(), obj.getPosY(), obj.getRadius());
            if( colision ){
              const objHealth = obj.getHealth()-10;
              if( objHealth <= 0){
                delete players[idx];
                break;
              }
              obj.setHealth(objHealth);
            }
          }
          
          // Object 그리기
          obj.draw();
        }
        self.cleanPlayers();
      }

      // 총알 그리기
      const _drawBullets = (self)=>{
        const bullets = self.getBullets();
        for(let idx=0; idx < bullets.length; idx++){
          const bullet = bullets[idx];
          if( bullet && bullet.isFired() ){
            bullet.draw();
          } else {
            delete bullets[idx];
          }
        }
        self.cleanBullets();
      }

      // Canvas 그리기 이벤트
      const _draw = (self)=>{
        // Canvas 그리기 서브 이벤트
        function drawer(){
          _clear(self); // Canvas 초기화

          _drawStage(self); // Stage 그리기
          _drawPlayers(self); // Player 그리기
          _drawBullets(self); // 총알 그리기

          // 현재 상태 저장
          self.setState("drawing", requestAnimationFrame(drawer));
        }
        // 그리는 중인 경우 중단
        cancelAnimationFrame(self.getState("drawing"));
        self.setState("drawing", null);
        
        // 그리기 시작
        drawer();
      }

      // Canvas 초기화 이벤트
      const _clear = (self)=>{
        self.getCtx().clearRect(0,0,self.getWidth(),self.getHeight());
      }

      // 시작 이벤트
      const _start = (self)=>{
        const isDrawing = self.getState("drawing");
        if( !isDrawing ){
          _draw(self);
        }
      }

      // 중단 이벤트
      const _stop = async (self)=>{
        const drawing = self.getState("drawing");
        if( drawing ){
          await cancelAnimationFrame(drawing);
          self.setState("drawing", null);
        }
      }

      // 종료 이벤트
      const _destroy = async (self)=>{
        await _stop(self);
        await _clear(self);
      }
      
      return {
        init(settings){
          _init(this, settings);
          return this;
        },
        start(){
          _start(this);
        },
        stop(){
          _stop(this);
        },
        destroy(){
          _destroy(this);
        }
      }
    })();

    const canvas = document.querySelector("canvas#canvas-playground");
    const player = new Player(
      canvas,
      {
        name: "me",
        size: "large",
        shape: {
          //type: "triangle",
          type: "rect",
          color: "grey",
        },
        // spawn
        pos: {
          x: 100,
          y: 100,
        },
        guide: {
          show: true,
        }
      }
    );
    const stage = new StageManager(
      canvas,
      { 
        size: { 
          // width: (window.screen.width/5)*4, 
          width: window.innerWidth,
          height: (window.screen.height/5)*3
        }
      }
    );
    stage.setPlayer(player);
    stage.start();

  </script>
  <script>

    setInterval(addEnemy, Math.random()*1000);

    function addEnemy(){
      const randToggle = parseInt(Math.random()*1.5);
      const randPos = {
        x: stage.getWidth() - parseInt(Math.random()*15)*10,
        y: ( randToggle === 0 ? stage.getHeight() : Math.random()*stage.getHeight() ),
      }
      const NPC = new Player(
        stage.getCanvas(),
        {
          name: "NPC-"+(stage.getPlayers().length+1),
          inputType: document.querySelector("[name=inputType]").value,
          size: "small",
          follow: stage.getPlayer(),
          // follow: "pointer",
          shape: {
            type: document.querySelector("[name=shape]").value,
            color: document.querySelector("[name=color]").value,
          },
          pos: {
            x: randPos.x,
            y: randPos.y,
          },
        }
      );
      NPC.setMoveSpeed(Math.random()*3+1);

      stage.addPlayer(NPC);
    }
  </script>
  <script type="text/javascript">
    document.querySelector("#addPlayer").addEventListener("click", (e)=>{
      e.preventDefault();
      addEnemy();
      return false;
    });
    document.body.addEventListener("keydown", (e)=>{
      if( e.keyCode === 32 /* SpaceBar */ ){
        const triggerElement = document.querySelector("#addPlayer");
        const triggerEventType = "click";
        if( typeof document.createEvent === "function" ){
          // IE9+ and other modern browsers
          const triggerEvent = document.createEvent('HTMLEvents');
          triggerEvent.initEvent(triggerEventType, false, true);
          triggerElement.dispatchEvent(triggerEvent); 
        } else {
          // IE8
          const triggerEvent = document.createEventObject();
          triggerEvent.eventType = triggerEventType;
          triggerElement.fireEvent('on' + triggerEvent.eventType, e);
        }
      }
    });
    document.querySelector("#stop").addEventListener("click", (e)=>{
      e.preventDefault();
      stage.stop();
    });
    document.querySelector("#reset").addEventListener("click", (e)=>{
      e.preventDefault();
      stage.init();
    });
    document.querySelector("#destroy").addEventListener("click", (e)=>{
      e.preventDefault();
      stage.destroy();
    });
  </script>
</body>
</html>